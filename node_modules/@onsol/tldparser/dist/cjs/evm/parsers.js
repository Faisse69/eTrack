"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TldParserEvm = void 0;
const ethers_1 = require("ethers");
const registrar_fetchers_1 = require("./fetchers/registrar.fetchers");
const registry_fetchers_1 = require("./fetchers/registry.fetchers");
const root_fetchers_1 = require("./fetchers/root.fetchers");
const Address_1 = require("./types/Address");
const utils_1 = require("./utils");
class TldParserEvm {
    constructor(settings) {
        if (settings instanceof utils_1.NetworkWithRpc) {
            const chainId = parseInt(settings.chainId.toString());
            const config = (0, utils_1.configOfEvmChainId)(chainId);
            this.config = config;
            settings.attachPlugin(new ethers_1.EnsPlugin(config.registryContractAddress, chainId));
            this.connection = new ethers_1.JsonRpcProvider(settings.rpcUrl, settings, {
                staticNetwork: true,
            });
        }
        else {
            throw new Error('Method not implemented.');
        }
    }
    getAllUserDomains(userAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidAddr = (0, Address_1.isValidAddress)(userAccount);
            if (!isValidAddr) {
                throw new Error(`Invalid address for EVM chain: ${userAccount}`);
            }
            const tlds = yield root_fetchers_1.rootFetchers.getTlds({
                config: this.config,
                provider: this.connection,
            });
            const domains = (yield Promise.all(tlds.map(tld => {
                return this.getUserNftFromTld({
                    userAccount: userAccount,
                    tld,
                });
            }))).flat();
            return domains.map(domain => {
                return {
                    created_at: '0',
                    domain_name: domain.nft.name,
                    expires_at: domain.nft.expiry.toString(),
                    main_domain_address: '',
                    tld: domain.tld.tld,
                    transferrable: domain.nft.frozen,
                };
            });
        });
    }
    getAllUserDomainsFromTld(userAccount, tld) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidAddr = (0, Address_1.isValidAddress)(userAccount);
            if (!isValidAddr) {
                throw new Error(`Invalid address for EVM chain: ${userAccount}`);
            }
            const tldLabel = (0, utils_1.labelhashFromLabel)(tld);
            const tldData = yield root_fetchers_1.rootFetchers.getTldData({
                config: this.config,
                provider: this.connection,
                tldLabel,
            });
            const domains = yield this.getUserNftFromTld({
                userAccount: userAccount,
                tld: tldData,
            });
            return domains.map(domain => {
                return {
                    created_at: '0',
                    domain_name: domain.nft.name,
                    expires_at: domain.nft.expiry.toString(),
                    main_domain_address: '',
                    tld: domain.tld.tld,
                    transferrable: domain.nft.frozen,
                };
            });
        });
    }
    getOwnerFromDomainTld(domainTld) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = (0, utils_1.ansNamehash)(domainTld);
            const owner = yield registry_fetchers_1.registryFetchers.getDomainOwner({
                config: this.config,
                provider: this.connection,
                registryAddress: this.config.registryContractAddress,
                node,
            });
            return owner;
        });
    }
    getNameRecordFromDomainTld(domainTld) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalized = (0, ethers_1.ensNormalize)(domainTld);
            const node = (0, utils_1.ansNamehash)(normalized);
            const recordData = yield registry_fetchers_1.registryFetchers.getRecordData({
                config: this.config,
                provider: this.connection,
                registryAddress: this.config.registryContractAddress,
                node,
            });
            const tld = yield this.getTldFromFullDomain(domainTld);
            const tldData = yield root_fetchers_1.rootFetchers.getTldData({
                config: this.config,
                provider: this.connection,
                tldLabel: (0, utils_1.labelhashFromLabel)(tld),
            });
            const nftData = yield registrar_fetchers_1.registrarFetchers.getUserNftData({
                config: this.config,
                provider: this.connection,
                registrarAddress: tldData.registrar,
                domain: domainTld,
            });
            return {
                created_at: (nftData.expiry - recordData.ttl).toString(),
                domain_name: nftData.name,
                expires_at: nftData.expiry.toString(),
                main_domain_address: recordData.owner,
                tld: `${tldData.name}`,
                transferrable: !nftData.frozen,
            };
        });
    }
    getTldFromParentAccount(parentAccount) {
        throw new Error('Method not implemented.');
    }
    reverseLookupNameAccount(nameAccount, parentAccountOwner) {
        throw new Error('Method not implemented.');
    }
    getMainDomain(userAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidAddr = (0, Address_1.isValidAddress)(userAddress);
            if (!isValidAddr) {
                throw new Error(`Invalid address for EVM chain: ${userAddress}`);
            }
            const mainDomain = yield registrar_fetchers_1.registrarFetchers.getMainDomainRaw({
                provider: this.connection,
                address: userAddress,
                rootAddress: this.config.rootContractAddress
            });
            if (!mainDomain) {
                throw new Error(`No main domain found for: ${userAddress}`);
            }
            return (yield this.getNameRecordFromDomainTld(mainDomain));
        });
    }
    getParsedAllUserDomainsFromTldUnwrapped(userAccount, tld) {
        throw new Error('Method not implemented.');
    }
    getParsedAllUserDomainsFromTld(userAccount, tld) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidAddr = (0, Address_1.isValidAddress)(userAccount);
            if (!isValidAddr) {
                throw new Error(`Invalid address for EVM chain: ${userAccount}`);
            }
            const tldLabel = (0, utils_1.labelhashFromLabel)(tld);
            const tldData = yield root_fetchers_1.rootFetchers.getTldData({
                config: this.config,
                provider: this.connection,
                tldLabel,
            });
            const domains = yield this.getUserNftFromTld({
                userAccount: userAccount,
                tld: tldData,
            });
            return domains.map(domain => {
                return {
                    address: domain.nft.name,
                    domain: domain.tld.tld,
                };
            });
        });
    }
    getParsedAllUserDomainsUnwrapped(userAccount) {
        throw new Error('Method not implemented.');
    }
    getParsedAllUserDomains(userAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const isValidAddr = (0, Address_1.isValidAddress)(userAccount);
            if (!isValidAddr) {
                throw new Error(`Invalid address for EVM chain: ${userAccount}`);
            }
            const tlds = yield root_fetchers_1.rootFetchers.getTlds({
                config: this.config,
                provider: this.connection,
            });
            const domains = (yield Promise.all(tlds.map(tld => {
                return this.getUserNftFromTld({
                    userAccount: userAccount,
                    tld,
                });
            }))).flat();
            return domains.map(domain => {
                return {
                    address: domain.nft.name,
                    domain: domain.tld.tld,
                };
            });
        });
    }
    getUserNftFromTld(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const { tld, userAccount } = data;
            const registrar = tld.registrar;
            const nftData = yield registrar_fetchers_1.registrarFetchers.getUsersNfts({
                config: this.config,
                provider: this.connection,
                registrarAddress: registrar,
                userAddress: userAccount,
            });
            return nftData.map(nft => {
                return {
                    nft,
                    tld,
                };
            });
        });
    }
    getBaseRegistry(chainId) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, utils_1.configOfEvmChainId)(chainId);
            const data = yield root_fetchers_1.rootFetchers.getRegistryAddress({
                config,
                provider: this.connection,
            });
            return data;
        });
    }
    getTldFromFullDomain(domain) {
        return __awaiter(this, void 0, void 0, function* () {
            // Considering there can be unlimited subdomains, the last part after a dot is the tld
            const parts = domain.split('.');
            const tld = parts[parts.length - 1];
            return '.' + tld;
        });
    }
}
exports.TldParserEvm = TldParserEvm;
//# sourceMappingURL=parsers.js.map