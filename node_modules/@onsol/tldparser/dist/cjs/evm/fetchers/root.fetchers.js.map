{"version":3,"file":"root.fetchers.js","sourceRoot":"","sources":["../../../../src/evm/fetchers/root.fetchers.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;AAEb,mCAA4C;AA6B5C,SAAe,kBAAkB,CAAC,MAGjC;;QACG,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;QAEpC,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAE3D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,MAAM,CAAC,mBAAmB,EAC1B,CAAC,4CAA4C,CAAC,EAC9C,QAAQ,CACX,CAAC;QAEF,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,QAAQ,EAAE,CAAC;QAE1C,OAAO,OAAO,CAAC;IACnB,CAAC;CAAA;AAED,SAAe,UAAU,CAAC,MAIzB;;QACG,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,GAAG,MAAM,CAAC;QAE9C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAE1C,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,MAAM,CAAC,mBAAmB,EAC1B;YACI,4GAA4G;SAC/G,EACD,QAAQ,CACX,CAAC;QAEF,MAAM,UAAU,GAAG,MAAM,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAEnD,MAAM,CAAC,UAAU,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,GACjE,UAAU,CAAC;QAEf,OAAO;YACH,UAAU,EAAE,UAAqB;YACjC,SAAS,EAAE,SAAoB;YAC/B,GAAG,EAAE,GAAa;YAClB,IAAI,EAAE,IAAc;YACpB,MAAM,EAAE,MAAgB;YACxB,MAAM,EAAG,MAAiB,KAAK,MAAM;YACrC,IAAI,EAAE,IAAc;YACpB,KAAK,EAAE,KAAe;SACzB,CAAC;IACN,CAAC;CAAA;AAED,SAAe,OAAO,CAAC,MAGtB;;QACG,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;QAEpC,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAE3D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,MAAM,CAAC,mBAAmB,EAC1B;YACI,yGAAyG;SAC5G,EACD,QAAQ,CACX,CAAC;QAEF,MAAM,OAAO,GAAG,CAAC,MAAM,QAAQ,CAAC,QAAQ,EAAE,CASvC,CAAC;QAEJ,MAAM,IAAI,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,MAAM,EAAO,EAAE;YACrC,MAAM,CAAC,UAAU,EAAE,SAAS,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,GACjE,MAAM,CAAC;YAEX,OAAO;gBACH,UAAU,EAAE,UAAqB;gBACjC,SAAS,EAAE,SAAoB;gBAC/B,GAAG,EAAE,GAAa;gBAClB,IAAI,EAAE,IAAc;gBACpB,MAAM,EAAE,MAAgB;gBACxB,MAAM,EAAG,MAAiB,KAAK,MAAM;gBACrC,IAAI,EAAE,IAAc;gBACpB,KAAK,EAAE,KAAe;aACzB,CAAC;QACN,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC;IAChB,CAAC;CAAA;AAEY,QAAA,YAAY,GAAG;IACxB,kBAAkB;IAClB,OAAO;IACP,UAAU;CACb,CAAC","sourcesContent":["'use strict';\n\nimport { Contract, Provider } from 'ethers';\n\nimport { Address } from '../types/Address';\nimport { EvmChainData } from '../types/EvmChainData';\n\nexport type TLD = {\n    controller: Address;\n    registrar: Address;\n    tld: string;\n    name: string;\n    symbol: string;\n    locked: boolean;\n    node: string;\n    label: string;\n};\n\nexport type PriceSchema = {\n    for1: number;\n    for2: number;\n    for3: number;\n    for4: number;\n    for5plus: number;\n};\n\nexport type SplitSchema = {\n    percentage: number;\n    recipient: Address;\n};\n\nasync function getRegistryAddress(params: {\n    config: EvmChainData;\n    provider: Provider;\n}): Promise<Address> {\n    const { provider, config } = params;\n\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n\n    const contract = new Contract(\n        config.rootContractAddress,\n        ['function registry() view returns (address)'],\n        provider,\n    );\n\n    const address = await contract.registry();\n\n    return address;\n}\n\nasync function getTldData(params: {\n    config: EvmChainData;\n    provider: Provider;\n    tldLabel: string;\n}): Promise<TLD> {\n    const { config, tldLabel, provider } = params;\n\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!provider) throw Error('No provider');\n\n    const contract = new Contract(\n        config.rootContractAddress,\n        [\n            'function getTld(bytes32) view returns ((address, address, string, string, string, bool, bytes32, bytes32))',\n        ],\n        provider,\n    );\n\n    const tldDataRaw = await contract.getTld(tldLabel);\n\n    const [controller, registrar, tld, name, symbol, locked, node, label] =\n        tldDataRaw;\n\n    return {\n        controller: controller as Address,\n        registrar: registrar as Address,\n        tld: tld as string,\n        name: name as string,\n        symbol: symbol as string,\n        locked: (locked as string) === 'true',\n        node: node as string,\n        label: label as string,\n    };\n}\n\nasync function getTlds(params: {\n    config: EvmChainData;\n    provider: Provider;\n}): Promise<TLD[]> {\n    const { provider, config } = params;\n\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n\n    const contract = new Contract(\n        config.rootContractAddress,\n        [\n            'function listTlds() view returns ((address, address, string, string, string, bool, bytes32, bytes32)[])',\n        ],\n        provider,\n    );\n\n    const tldsRaw = (await contract.listTlds()) as [\n        unknown, // controller\n        unknown, // registrar\n        unknown, // tld\n        unknown, // name\n        unknown, // symbol\n        unknown, // locked\n        unknown, // node\n        unknown, // label\n    ][];\n\n    const tlds = tldsRaw.map((tldRaw): TLD => {\n        const [controller, registrar, tld, name, symbol, locked, node, label] =\n            tldRaw;\n\n        return {\n            controller: controller as Address,\n            registrar: registrar as Address,\n            tld: tld as string,\n            name: name as string,\n            symbol: symbol as string,\n            locked: (locked as string) === 'true',\n            node: node as string,\n            label: label as string,\n        };\n    });\n\n    return tlds;\n}\n\nexport const rootFetchers = {\n    getRegistryAddress,\n    getTlds,\n    getTldData,\n};\n"]}