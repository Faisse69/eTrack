{"version":3,"file":"registry.fetchers.js","sourceRoot":"","sources":["../../../../src/evm/fetchers/registry.fetchers.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;AAEb,mCAA4C;AAW5C,SAAe,cAAc,CAAC,MAK7B;;QACG,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG,MAAM,CAAC;QAC3D,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,eAAe;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAE1D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,eAAe,EACf,CAAC,gDAAgD,CAAC,EAClD,QAAQ,CACX,CAAC;QACF,MAAM,KAAK,GAAG,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAEzC,OAAO,KAAK,CAAC;IACjB,CAAC;CAAA;AAED,SAAe,aAAa,CAAC,MAK5B;;QACG,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,eAAe,EAAE,GAAG,MAAM,CAAC;QAC3D,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,eAAe;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAE1D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,eAAe,EACf;YACI,gDAAgD;YAChD,mDAAmD;YACnD,8CAA8C;SACjD,EACD,QAAQ,CACX,CAAC;QACF,MAAM,KAAK,GAAG,MAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QACzC,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC/C,MAAM,GAAG,GAAG,MAAM,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAErC,OAAO;YACH,KAAK;YACL,QAAQ;YACR,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;SAC9B,CAAC;IACN,CAAC;CAAA;AAEY,QAAA,gBAAgB,GAAG;IAC5B,cAAc;IACd,aAAa;CAChB,CAAC","sourcesContent":["'use strict';\n\nimport { Contract, Provider } from 'ethers';\n\nimport { Address } from '../types/Address';\nimport { EvmChainData } from '../types/EvmChainData';\n\ntype RecordData = {\n    owner: Address;\n    resolver: Address;\n    ttl: bigint;\n};\n\nasync function getDomainOwner(params: {\n    node: string;\n    config: EvmChainData;\n    provider: Provider;\n    registryAddress: Address | undefined;\n}): Promise<Address> {\n    const { node, config, provider, registryAddress } = params;\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registryAddress) throw Error('No registrar address');\n\n    const contract = new Contract(\n        registryAddress,\n        ['function owner(bytes32) view returns (address)'],\n        provider,\n    );\n    const owner = await contract.owner(node);\n\n    return owner;\n}\n\nasync function getRecordData(params: {\n    node: string;\n    config: EvmChainData;\n    provider: Provider;\n    registryAddress: Address | undefined;\n}): Promise<RecordData> {\n    const { node, config, provider, registryAddress } = params;\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registryAddress) throw Error('No registrar address');\n\n    const contract = new Contract(\n        registryAddress,\n        [\n            'function owner(bytes32) view returns (address)',\n            'function resolver(bytes32) view returns (address)',\n            'function ttl(bytes32) view returns (uint256)',\n        ],\n        provider,\n    );\n    const owner = await contract.owner(node);\n    const resolver = await contract.resolver(node);\n    const ttl = await contract.ttl(node);\n\n    return {\n        owner,\n        resolver,\n        ttl: BigInt(ttl.toString()),\n    };\n}\n\nexport const registryFetchers = {\n    getDomainOwner,\n    getRecordData,\n};\n"]}