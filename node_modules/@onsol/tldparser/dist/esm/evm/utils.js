"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ansNamehash = exports.namehashFromDomain = exports.labelhashFromLabel = exports.configOfEvmChainId = exports.getValues = exports.NetworkWithRpc = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
class NetworkWithRpc extends ethers_1.Network {
    constructor(name, chainId, rpcUrl) {
        super(name, chainId);
        this.rpcUrl = rpcUrl;
    }
}
exports.NetworkWithRpc = NetworkWithRpc;
function getValues(obj) {
    return Object.values(obj);
}
exports.getValues = getValues;
function configOfEvmChainId(chainId) {
    if (chainId === undefined)
        return undefined;
    const config = Object.values(constants_1.EVM_CHAIN_CONFIGS).find(chainData => {
        return chainData.chainId === chainId;
    });
    if (config === undefined) {
        throw new Error(`ChainId ${chainId} is not currently supported`);
    }
    return config;
}
exports.configOfEvmChainId = configOfEvmChainId;
function labelhashFromLabel(label) {
    const labelhash = (0, ethers_1.keccak256)((0, ethers_1.toUtf8Bytes)(label));
    return labelhash;
}
exports.labelhashFromLabel = labelhashFromLabel;
function namehashFromDomain(domain) {
    const label = ansNamehash(domain);
    return label;
}
exports.namehashFromDomain = namehashFromDomain;
function ansNamehash(name) {
    let result = ethers_1.ZeroHash;
    const comps = ansNameSplit(name);
    while (comps.length) {
        result = (0, ethers_1.keccak256)((0, ethers_1.concat)([result, (0, ethers_1.keccak256)((comps.pop()))]));
    }
    return (0, ethers_1.hexlify)(result);
}
exports.ansNamehash = ansNamehash;
function ansNameSplit(name) {
    const bytes = (0, ethers_1.toUtf8Bytes)((0, ethers_1.ensNormalize)(name));
    const comps = [];
    if (name.length === 0) {
        return comps;
    }
    let last = 0;
    for (let i = 0; i < bytes.length; i++) {
        const d = bytes[i];
        // A separator (i.e. "."); copy this component including the dot
        if (d === 0x2e) {
            comps.push(bytes.slice(last, i));
            last = i + 1;
        }
    }
    comps.push(bytes.slice(last - 1));
    return comps;
}
//# sourceMappingURL=utils.js.map