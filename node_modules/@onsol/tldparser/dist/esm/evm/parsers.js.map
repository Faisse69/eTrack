{"version":3,"file":"parsers.js","sourceRoot":"","sources":["../../../src/evm/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Connection, PublicKey } from '@solana/web3.js';\nimport { ensNormalize, EnsPlugin, JsonRpcProvider } from 'ethers';\n\nimport { ITldParser } from '../parsers.interface';\nimport { MainDomain, NameAccountAndDomain, NameRecordHeader } from '../svm';\nimport { registrarFetchers } from './fetchers/registrar.fetchers';\nimport { registryFetchers } from './fetchers/registry.fetchers';\nimport { rootFetchers, TLD } from './fetchers/root.fetchers';\nimport { Address, isValidAddress } from './types/Address';\nimport { AddressAndDomain } from './types/AddressAndDomain';\nimport { EvmChainData } from './types/EvmChainData';\nimport {\n    configOfEvmChainId,\n    labelhashFromLabel,\n    ansNamehash,\n    NetworkWithRpc,\n} from './utils';\nimport { NameRecord } from './types/NameRecordHeader';\n\nexport class TldParserEvm implements ITldParser {\n    connection: JsonRpcProvider;\n    private config: EvmChainData;\n\n    constructor(settings?: Connection | NetworkWithRpc) {\n        if (settings instanceof NetworkWithRpc) {\n            const chainId = parseInt(settings.chainId.toString());\n            const config = configOfEvmChainId(chainId);\n            this.config = config;\n\n            settings.attachPlugin(\n                new EnsPlugin(config.registryContractAddress, chainId),\n            );\n            this.connection = new JsonRpcProvider(settings.rpcUrl, settings, {\n                staticNetwork: true,\n            });\n        } else {\n            throw new Error('Method not implemented.');\n        }\n    }\n\n    async getAllUserDomains(\n        userAccount: string,\n    ): Promise<NameRecord[]> {\n        const isValidAddr = isValidAddress(userAccount as string);\n        if (!isValidAddr) {\n            throw new Error(`Invalid address for EVM chain: ${userAccount}`);\n        }\n\n        const tlds = await rootFetchers.getTlds({\n            config: this.config,\n            provider: this.connection,\n        });\n\n        const domains = (\n            await Promise.all(\n                tlds.map(tld => {\n                    return this.getUserNftFromTld({\n                        userAccount: userAccount as string,\n                        tld,\n                    });\n                }),\n            )\n        ).flat();\n\n        return domains.map(domain => {\n            return <NameRecord>{\n                created_at: '0',\n                domain_name: domain.nft.name,\n                expires_at: domain.nft.expiry.toString(),\n                main_domain_address: '',\n                tld: domain.tld.tld,\n                transferrable: domain.nft.frozen,\n            };\n        });\n    }\n\n    async getAllUserDomainsFromTld(\n        userAccount: string,\n        tld: string,\n    ): Promise<PublicKey[] | NameRecord[]> {\n        const isValidAddr = isValidAddress(userAccount as string);\n        if (!isValidAddr) {\n            throw new Error(`Invalid address for EVM chain: ${userAccount}`);\n        }\n\n        const tldLabel = labelhashFromLabel(tld);\n\n        const tldData = await rootFetchers.getTldData({\n            config: this.config,\n            provider: this.connection,\n            tldLabel,\n        });\n\n        const domains = await this.getUserNftFromTld({\n            userAccount: userAccount as string,\n            tld: tldData,\n        });\n\n        return domains.map(domain => {\n            return <NameRecord>{\n                created_at: '0',\n                domain_name: domain.nft.name,\n                expires_at: domain.nft.expiry.toString(),\n                main_domain_address: '',\n                tld: domain.tld.tld,\n                transferrable: domain.nft.frozen,\n            };\n        });\n    }\n\n    async getOwnerFromDomainTld(\n        domainTld: string,\n    ): Promise<PublicKey | undefined | string> {\n        const node = ansNamehash(domainTld);\n        const owner = await registryFetchers.getDomainOwner({\n            config: this.config,\n            provider: this.connection,\n            registryAddress: this.config.registryContractAddress as Address,\n            node,\n        });\n\n        return owner;\n    }\n\n    async getNameRecordFromDomainTld(\n        domainTld: string,\n    ): Promise<NameRecordHeader | NameRecord | undefined> {\n        const normalized = ensNormalize(domainTld);\n        const node = ansNamehash(normalized);\n        const recordData = await registryFetchers.getRecordData({\n            config: this.config,\n            provider: this.connection,\n            registryAddress: this.config.registryContractAddress as Address,\n            node,\n        });\n\n        const tld = await this.getTldFromFullDomain(domainTld);\n        const tldData = await rootFetchers.getTldData({\n            config: this.config,\n            provider: this.connection,\n            tldLabel: labelhashFromLabel(tld),\n        });\n\n        const nftData = await registrarFetchers.getUserNftData({\n            config: this.config,\n            provider: this.connection,\n            registrarAddress: tldData.registrar as Address,\n            domain: domainTld,\n        });\n\n        return <NameRecord>{\n            created_at: (nftData.expiry - recordData.ttl).toString(),\n            domain_name: nftData.name,\n            expires_at: nftData.expiry.toString(),\n            main_domain_address: recordData.owner,\n            tld: `${tldData.name}`,\n            transferrable: !nftData.frozen,\n        };\n    }\n\n    getTldFromParentAccount(\n        parentAccount: PublicKey | string,\n    ): Promise<string> {\n        throw new Error('Method not implemented.');\n    }\n\n    reverseLookupNameAccount(\n        nameAccount: PublicKey | string,\n        parentAccountOwner: PublicKey | string,\n    ): Promise<string> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getMainDomain(\n        userAddress: PublicKey | string,\n    ): Promise<MainDomain | NameRecord> {\n        const isValidAddr = isValidAddress(userAddress as string);\n        if (!isValidAddr) {\n            throw new Error(`Invalid address for EVM chain: ${userAddress}`);\n        }\n\n        const mainDomain = await registrarFetchers.getMainDomainRaw({\n            provider: this.connection,\n            address: userAddress as Address,\n            rootAddress: this.config.rootContractAddress as Address\n        })\n        \n        if (!mainDomain) {\n            throw new Error(`No main domain found for: ${userAddress}`);\n        }\n        return (await this.getNameRecordFromDomainTld(mainDomain)) as NameRecord;\n    }\n\n    getParsedAllUserDomainsFromTldUnwrapped(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<NameAccountAndDomain[]> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getParsedAllUserDomainsFromTld(\n        userAccount: PublicKey | string,\n        tld: string,\n    ): Promise<NameAccountAndDomain[] | AddressAndDomain[]> {\n        const isValidAddr = isValidAddress(userAccount as string);\n        if (!isValidAddr) {\n            throw new Error(`Invalid address for EVM chain: ${userAccount}`);\n        }\n\n        const tldLabel = labelhashFromLabel(tld);\n\n        const tldData = await rootFetchers.getTldData({\n            config: this.config,\n            provider: this.connection,\n            tldLabel,\n        });\n\n        const domains = await this.getUserNftFromTld({\n            userAccount: userAccount as string,\n            tld: tldData,\n        });\n\n        return domains.map(domain => {\n            return <AddressAndDomain>{\n                address: domain.nft.name,\n                domain: domain.tld.tld,\n            };\n        });\n    }\n\n    getParsedAllUserDomainsUnwrapped(\n        userAccount: PublicKey | string,\n    ): Promise<NameAccountAndDomain[] | AddressAndDomain[]> {\n        throw new Error('Method not implemented.');\n    }\n\n    async getParsedAllUserDomains(\n        userAccount: PublicKey | string,\n    ): Promise<NameAccountAndDomain[] | AddressAndDomain[]> {\n        const isValidAddr = isValidAddress(userAccount as string);\n        if (!isValidAddr) {\n            throw new Error(`Invalid address for EVM chain: ${userAccount}`);\n        }\n\n        const tlds = await rootFetchers.getTlds({\n            config: this.config,\n            provider: this.connection,\n        });\n\n        const domains = (\n            await Promise.all(\n                tlds.map(tld => {\n                    return this.getUserNftFromTld({\n                        userAccount: userAccount as string,\n                        tld,\n                    });\n                }),\n            )\n        ).flat();\n\n        return domains.map(domain => {\n            return <AddressAndDomain>{\n                address: domain.nft.name,\n                domain: domain.tld.tld,\n            };\n        });\n    }\n\n    private async getUserNftFromTld(data: { userAccount: string; tld: TLD }) {\n        const { tld, userAccount } = data;\n        const registrar = tld.registrar;\n        const nftData = await registrarFetchers.getUsersNfts({\n            config: this.config,\n            provider: this.connection,\n            registrarAddress: registrar as Address,\n            userAddress: userAccount as Address,\n        });\n\n        return nftData.map(nft => {\n            return {\n                nft,\n                tld,\n            };\n        });\n    }\n\n    private async getBaseRegistry(chainId: number): Promise<string> {\n        const config = configOfEvmChainId(chainId);\n\n        const data = await rootFetchers.getRegistryAddress({\n            config,\n            provider: this.connection,\n        });\n\n        return data;\n    }\n\n    private async getTldFromFullDomain(domain: string) {\n        // Considering there can be unlimited subdomains, the last part after a dot is the tld\n        const parts = domain.split('.');\n        const tld = parts[parts.length - 1];\n        return '.' + tld;\n    }\n}\n"]}