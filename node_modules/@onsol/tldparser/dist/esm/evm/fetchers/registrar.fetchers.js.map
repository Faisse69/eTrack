{"version":3,"file":"registrar.fetchers.js","sourceRoot":"","sources":["../../../../src/evm/fetchers/registrar.fetchers.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;AAEb,mCAAiE;AAIjE,oCAA8C;AAoB9C,SAAe,WAAW,CAAC,MAK1B;;QACG,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE,GAAG,MAAM,CAAC;QAC5D,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAE3D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,gBAAgB,EAChB,CAAC,kEAAkE,CAAC,EACpE,QAAQ,CACX,CAAC;QACF,MAAM,QAAQ,GAAG,MAAM,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAE/C,OAAO,QAAQ,CAAC;IACpB,CAAC;CAAA;AAED,SAAe,SAAS,CAAC,MAIxB;;QACG,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE,GAAG,MAAM,CAAC;QAEtD,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAE3D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,gBAAgB,EAChB;YACI,uCAAuC;YACvC,yCAAyC;YACzC,0CAA0C;YAC1C,yCAAyC;YACzC,0CAA0C;YAC1C,+CAA+C;YAC/C,0CAA0C;YAC1C,8CAA8C;SACjD,EACD,QAAQ,CACX,CAAC;QAEF,MAAM,IAAI,GAAG,CAAC,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAsB,CAAC;QAC1D,MAAM,KAAK,GAAG,CAAC,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAsB,CAAC;QAC5D,MAAM,OAAO,GAAG,CAAC,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAsB,CAAC;QAChE,MAAM,MAAM,GAAG,CAAC,MAAM,QAAQ,CAAC,MAAM,EAAE,CAAsB,CAAC;QAC9D,MAAM,OAAO,GAAG,CAAC,MAAM,QAAQ,CAAC,OAAO,EAAE,CAAsB,CAAC;QAChE,MAAM,WAAW,GAAG,CAAC,MAAM,QAAQ,CAAC,WAAW,EAAE,CAAsB,CAAC;QACxE,MAAM,SAAS,GAAG,CAAC,MAAM,QAAQ,CAAC,SAAS,EAAE,CAAuB,CAAC;QACrE,MAAM,UAAU,GAAG,CAAC,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAsB,CAAC;QAEtE,OAAO;YACH,IAAI;YACJ,KAAK,EAAE,KAAgB;YACvB,OAAO;YACP,MAAM;YACN,OAAO;YACP,WAAW,EAAE,QAAQ,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC;YAC7C,SAAS;YACT,UAAU,EAAE,QAAQ,CAAC,UAAU,CAAC,QAAQ,EAAE,CAAC;SAC9C,CAAC;IACN,CAAC;CAAA;AAED,SAAe,YAAY,CAAC,MAK3B;;QACG,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE,WAAW,EAAE,GAAG,MAAM,CAAC;QAEnE,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAC3D,IAAI,CAAC,WAAW;YAAE,MAAM,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAEjD,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,gBAAgB,EAChB;YACI,wDAAwD;YACxD,mEAAmE;YACnE,kDAAkD;SACrD,EACD,QAAQ,CACX,CAAC;QAEF,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;QAErD,MAAM,OAAO,GAAG,EAAe,CAAC;QAChC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,MAAM,OAAO,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACxB,MAAM,YAAY,GAAG,CAAC,MAAM,QAAQ,CAAC,QAAQ,CACzC,cAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CACzB,CAAgC,CAAC;YAClC,MAAM,QAAQ,GAAG,CAAC,MAAM,QAAQ,CAAC,QAAQ,CACrC,OAAO,CACV,CAAsB,CAAC;YAExB,OAAO,CAAC,IAAI,CAAC;gBACT,IAAI,EAAE,YAAY,CAAC,CAAC,CAAW;gBAC/B,MAAM,EAAE,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAW,CAAC;gBAC3C,MAAM,EAAE,YAAY,CAAC,CAAC,CAAY;gBAClC,EAAE,EAAE,OAAO;gBACX,GAAG,EAAE,QAAQ;aAChB,CAAC,CAAC;SACN;QAED,OAAO,OAAO,CAAC;IACnB,CAAC;CAAA;AAED,SAAe,cAAc,CAAC,MAK7B;;QACG,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,gBAAgB,EAAE,MAAM,EAAE,GAAG,MAAM,CAAC;QAC9D,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,MAAM;YAAE,MAAM,KAAK,CAAC,gCAAgC,CAAC,CAAC;QAC3D,IAAI,CAAC,gBAAgB;YAAE,MAAM,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAE3D,MAAM,QAAQ,GAAG,IAAI,iBAAQ,CACzB,gBAAgB,EAChB;YACI,mEAAmE;YACnE,kDAAkD;SACrD,EACD,QAAQ,CACX,CAAC;QAEF,0FAA0F;QAC1F,MAAM,UAAU,GAAG,IAAA,qBAAY,EAAC,MAAM,CAAC,CAAC;QACxC,MAAM,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QACvC,MAAM,SAAS,GAAG,IAAA,0BAAkB,EAAC,KAAK,CAAC,CAAC;QAE5C,mCAAmC;QACnC,MAAM,OAAO,GAAG,cAAK,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;QAEzC,8BAA8B;QAC9B,MAAM,YAAY,GAAG,CAAC,MAAM,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAIrD,CAAC;QACF,MAAM,QAAQ,GAAG,CAAC,MAAM,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAsB,CAAC;QAEzE,OAAO;YACH,IAAI,EAAE,YAAY,CAAC,CAAC,CAAW;YAC/B,MAAM,EAAE,MAAM,CAAC,YAAY,CAAC,CAAC,CAAW,CAAC;YACzC,MAAM,EAAE,YAAY,CAAC,CAAC,CAAY;YAClC,EAAE,EAAE,OAAO;YACX,GAAG,EAAE,QAAQ;SAChB,CAAC;IACN,CAAC;CAAA;AACD,SAAe,gBAAgB,CAAC,MAI/B;;QACG,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,WAAW,EAAE,GAAG,MAAM,CAAC;QAElD,IAAI,CAAC,QAAQ;YAAE,MAAM,KAAK,CAAC,aAAa,CAAC,CAAC;QAC1C,IAAI,CAAC,OAAO;YAAE,MAAM,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACjD,IAAI,CAAC,WAAW;YAAE,MAAM,KAAK,CAAC,iBAAiB,CAAC,CAAC;QAEjD,IAAI;YACA,MAAM,YAAY,GAAG,IAAI,iBAAQ,CAAC,WAAW,EAAE;gBAC3C,oDAAoD;aACvD,EAAE,QAAQ,CAAC,CAAC;YACb,MAAM,uBAAuB,GAAG,MAAM,YAAY,CAAC,gBAAgB,EAAE,CAAC;YAEtE,MAAM,wBAAwB,GAAG,IAAI,iBAAQ,CACzC,uBAAuB,EACvB;gBACI,+CAA+C;gBAC/C,mDAAmD;aACtD,EACD,QAAQ,CACX,CAAC;YACF,MAAM,WAAW,GAAG,MAAM,wBAAwB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YAEjE,MAAM,eAAe,GAAG,MAAM,wBAAwB,CAAC,eAAe,EAAE,CAAC;YAEzE,MAAM,gBAAgB,GAAG,IAAI,iBAAQ,CACjC,eAAe,EACf;gBACI,8CAA8C;aACjD,EACD,QAAQ,CACX,CAAC;YAEF,MAAM,UAAU,GAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;YAE5D,OAAO,UAAU,IAAI,IAAI,CAAC;SAC7B;QAAC,OAAO,KAAK,EAAE;YACZ,OAAO,CAAC,KAAK,CAAC,oCAAoC,EAAE,KAAK,CAAC,CAAC;YAC3D,OAAO,IAAI,CAAC;SACf;IACL,CAAC;CAAA;AAEY,QAAA,iBAAiB,GAAG;IAC7B,WAAW;IACX,SAAS;IACT,YAAY;IACZ,cAAc;IACd,gBAAgB;CACnB,CAAC","sourcesContent":["'use strict';\n\nimport { Contract, ensNormalize, Provider, Typed } from 'ethers';\n\nimport { Address } from '../types/Address';\nimport { EvmChainData } from '../types/EvmChainData';\nimport { labelhashFromLabel } from '../utils';\n\ntype NameData = {\n    name: string;\n    expiry: number;\n    frozen: boolean;\n};\nexport type UserNft = NameData & { id: bigint; url: string };\n\ntype ScData = {\n    name: string;\n    owner: Address;\n    tldNode: string;\n    symbol: string;\n    baseUrl: string;\n    gracePeriod: number;\n    tldFrozen: boolean;\n    defaultTTL: number;\n};\n\nasync function getNameData(params: {\n    name: string;\n    config: EvmChainData;\n    provider: Provider;\n    registrarAddress: Address | undefined;\n}): Promise<NameData> {\n    const { name, config, provider, registrarAddress } = params;\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registrarAddress) throw Error('No registrar address');\n\n    const contract = new Contract(\n        registrarAddress,\n        ['function nameData(string) view returns ((string, uint256, bool))'],\n        provider,\n    );\n    const nameData = await contract.nameData(name);\n\n    return nameData;\n}\n\nasync function getScData(params: {\n    config: EvmChainData;\n    provider: Provider;\n    registrarAddress: Address | undefined;\n}): Promise<ScData> {\n    const { config, provider, registrarAddress } = params;\n\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registrarAddress) throw Error('No registrar address');\n\n    const contract = new Contract(\n        registrarAddress,\n        [\n            'function name() view returns (string)',\n            'function owner() view returns (address)',\n            'function tldNode() view returns (string)',\n            'function symbol() view returns (string)',\n            'function baseUri() view returns (string)',\n            'function gracePeriod() view returns (uint256)',\n            'function allFrozen() view returns (bool)',\n            'function defaultTTL() view returns (uint256)',\n        ],\n        provider,\n    );\n\n    const name = (await contract.name()) as unknown as string;\n    const owner = (await contract.owner()) as unknown as string;\n    const tldNode = (await contract.tldNode()) as unknown as string;\n    const symbol = (await contract.symbol()) as unknown as string;\n    const baseUrl = (await contract.baseUri()) as unknown as string;\n    const gracePeriod = (await contract.gracePeriod()) as unknown as bigint;\n    const tldFrozen = (await contract.allFrozen()) as unknown as boolean;\n    const defaultTTL = (await contract.defaultTTL()) as unknown as bigint;\n\n    return {\n        name,\n        owner: owner as Address,\n        tldNode,\n        symbol,\n        baseUrl,\n        gracePeriod: parseInt(gracePeriod.toString()),\n        tldFrozen,\n        defaultTTL: parseInt(defaultTTL.toString()),\n    };\n}\n\nasync function getUsersNfts(params: {\n    config: EvmChainData;\n    provider: Provider;\n    registrarAddress: Address | undefined;\n    userAddress: Address | undefined;\n}): Promise<UserNft[]> {\n    const { config, provider, registrarAddress, userAddress } = params;\n\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registrarAddress) throw Error('No registrar address');\n    if (!userAddress) throw Error('No user address');\n\n    const contract = new Contract(\n        registrarAddress,\n        [\n            'function getUserNfts(address) view returns (uint256[])',\n            'function nameData(uint256) view returns ((string, uint256, bool))',\n            'function tokenURI(uint256) view returns (string)',\n        ],\n        provider,\n    );\n\n    const nfts = await contract.getUserNfts(userAddress);\n\n    const nftData = [] as UserNft[];\n    for (let i = 0; i < nfts.length; i++) {\n        const tokenId = nfts[i];\n        const tokenDataRaw = (await contract.nameData(\n            Typed.uint256(tokenId),\n        )) as [unknown, unknown, unknown];\n        const tokenUrl = (await contract.tokenURI(\n            tokenId,\n        )) as unknown as string;\n\n        nftData.push({\n            name: tokenDataRaw[0] as string,\n            expiry: parseInt(tokenDataRaw[1] as string),\n            frozen: tokenDataRaw[2] as boolean,\n            id: tokenId,\n            url: tokenUrl,\n        });\n    }\n\n    return nftData;\n}\n\nasync function getUserNftData(params: {\n    config: EvmChainData;\n    provider: Provider;\n    registrarAddress: Address | undefined;\n    domain: string;\n}) {\n    const { config, provider, registrarAddress, domain } = params;\n    if (!provider) throw Error('No provider');\n    if (!config) throw Error('Not connected to SmartContract');\n    if (!registrarAddress) throw Error('No registrar address');\n\n    const contract = new Contract(\n        registrarAddress,\n        [\n            'function nameData(uint256) view returns ((string, uint256, bool))',\n            'function tokenURI(uint256) view returns (string)',\n        ],\n        provider,\n    );\n\n    // Step 1 - convert full domain to only the name of the domain (e.g. domain.eth -> domain)\n    const normalized = ensNormalize(domain);\n    const label = normalized.split('.')[0];\n    const labelHash = labelhashFromLabel(label);\n\n    // Step 2 - convert node to tokenId\n    const tokenId = Typed.uint256(labelHash);\n\n    // Step 3 - get the token data\n    const tokenDataRaw = (await contract.nameData(tokenId)) as [\n        unknown,\n        unknown,\n        unknown,\n    ];\n    const tokenUrl = (await contract.tokenURI(tokenId)) as unknown as string;\n\n    return {\n        name: tokenDataRaw[0] as string,\n        expiry: BigInt(tokenDataRaw[1] as string),\n        frozen: tokenDataRaw[2] as boolean,\n        id: tokenId,\n        url: tokenUrl,\n    };\n}\nasync function getMainDomainRaw(params: {\n    provider: Provider;\n    address: Address;\n    rootAddress: Address;\n}): Promise<string | null> {\n    const { provider, address, rootAddress } = params;\n\n    if (!provider) throw Error('No provider');\n    if (!address) throw Error('No address provided');\n    if (!rootAddress) throw Error('No root address');\n\n    try {\n        const rootContract = new Contract(rootAddress, [\n            'function reverseRegistrar() view returns (address)'\n        ], provider);\n        const reverseRegistrarAddress = await rootContract.reverseRegistrar();\n\n        const reverseRegistrarContract = new Contract(\n            reverseRegistrarAddress,\n            [\n                'function node(address) view returns (bytes32)',\n                'function defaultResolver() view returns (address)'\n            ],\n            provider\n        );\n        const reverseNode = await reverseRegistrarContract.node(address);\n\n        const resolverAddress = await reverseRegistrarContract.defaultResolver();\n\n        const resolverContract = new Contract(\n            resolverAddress,\n            [\n                'function name(bytes32) view returns (string)'\n            ],\n            provider\n        );\n\n        const mainDomain = await resolverContract.name(reverseNode);\n\n        return mainDomain || null;\n    } catch (error) {\n        console.error('Error fetching primary ENS domain:', error);\n        return null;\n    }\n}\n\nexport const registrarFetchers = {\n    getNameData,\n    getScData,\n    getUsersNfts,\n    getUserNftData,\n    getMainDomainRaw\n};\n"]}