'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registrarFetchers = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
function getNameData(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { name, config, provider, registrarAddress } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        if (!registrarAddress)
            throw Error('No registrar address');
        const contract = new ethers_1.Contract(registrarAddress, ['function nameData(string) view returns ((string, uint256, bool))'], provider);
        const nameData = yield contract.nameData(name);
        return nameData;
    });
}
function getScData(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { config, provider, registrarAddress } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        if (!registrarAddress)
            throw Error('No registrar address');
        const contract = new ethers_1.Contract(registrarAddress, [
            'function name() view returns (string)',
            'function owner() view returns (address)',
            'function tldNode() view returns (string)',
            'function symbol() view returns (string)',
            'function baseUri() view returns (string)',
            'function gracePeriod() view returns (uint256)',
            'function allFrozen() view returns (bool)',
            'function defaultTTL() view returns (uint256)',
        ], provider);
        const name = (yield contract.name());
        const owner = (yield contract.owner());
        const tldNode = (yield contract.tldNode());
        const symbol = (yield contract.symbol());
        const baseUrl = (yield contract.baseUri());
        const gracePeriod = (yield contract.gracePeriod());
        const tldFrozen = (yield contract.allFrozen());
        const defaultTTL = (yield contract.defaultTTL());
        return {
            name,
            owner: owner,
            tldNode,
            symbol,
            baseUrl,
            gracePeriod: parseInt(gracePeriod.toString()),
            tldFrozen,
            defaultTTL: parseInt(defaultTTL.toString()),
        };
    });
}
function getUsersNfts(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { config, provider, registrarAddress, userAddress } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        if (!registrarAddress)
            throw Error('No registrar address');
        if (!userAddress)
            throw Error('No user address');
        const contract = new ethers_1.Contract(registrarAddress, [
            'function getUserNfts(address) view returns (uint256[])',
            'function nameData(uint256) view returns ((string, uint256, bool))',
            'function tokenURI(uint256) view returns (string)',
        ], provider);
        const nfts = yield contract.getUserNfts(userAddress);
        const nftData = [];
        for (let i = 0; i < nfts.length; i++) {
            const tokenId = nfts[i];
            const tokenDataRaw = (yield contract.nameData(ethers_1.Typed.uint256(tokenId)));
            const tokenUrl = (yield contract.tokenURI(tokenId));
            nftData.push({
                name: tokenDataRaw[0],
                expiry: parseInt(tokenDataRaw[1]),
                frozen: tokenDataRaw[2],
                id: tokenId,
                url: tokenUrl,
            });
        }
        return nftData;
    });
}
function getUserNftData(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { config, provider, registrarAddress, domain } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        if (!registrarAddress)
            throw Error('No registrar address');
        const contract = new ethers_1.Contract(registrarAddress, [
            'function nameData(uint256) view returns ((string, uint256, bool))',
            'function tokenURI(uint256) view returns (string)',
        ], provider);
        // Step 1 - convert full domain to only the name of the domain (e.g. domain.eth -> domain)
        const normalized = (0, ethers_1.ensNormalize)(domain);
        const label = normalized.split('.')[0];
        const labelHash = (0, utils_1.labelhashFromLabel)(label);
        // Step 2 - convert node to tokenId
        const tokenId = ethers_1.Typed.uint256(labelHash);
        // Step 3 - get the token data
        const tokenDataRaw = (yield contract.nameData(tokenId));
        const tokenUrl = (yield contract.tokenURI(tokenId));
        return {
            name: tokenDataRaw[0],
            expiry: BigInt(tokenDataRaw[1]),
            frozen: tokenDataRaw[2],
            id: tokenId,
            url: tokenUrl,
        };
    });
}
function getMainDomainRaw(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { provider, address, rootAddress } = params;
        if (!provider)
            throw Error('No provider');
        if (!address)
            throw Error('No address provided');
        if (!rootAddress)
            throw Error('No root address');
        try {
            const rootContract = new ethers_1.Contract(rootAddress, [
                'function reverseRegistrar() view returns (address)'
            ], provider);
            const reverseRegistrarAddress = yield rootContract.reverseRegistrar();
            const reverseRegistrarContract = new ethers_1.Contract(reverseRegistrarAddress, [
                'function node(address) view returns (bytes32)',
                'function defaultResolver() view returns (address)'
            ], provider);
            const reverseNode = yield reverseRegistrarContract.node(address);
            const resolverAddress = yield reverseRegistrarContract.defaultResolver();
            const resolverContract = new ethers_1.Contract(resolverAddress, [
                'function name(bytes32) view returns (string)'
            ], provider);
            const mainDomain = yield resolverContract.name(reverseNode);
            return mainDomain || null;
        }
        catch (error) {
            console.error('Error fetching primary ENS domain:', error);
            return null;
        }
    });
}
exports.registrarFetchers = {
    getNameData,
    getScData,
    getUsersNfts,
    getUserNftData,
    getMainDomainRaw
};
//# sourceMappingURL=registrar.fetchers.js.map