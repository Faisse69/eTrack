'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rootFetchers = void 0;
const ethers_1 = require("ethers");
function getRegistryAddress(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { provider, config } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        const contract = new ethers_1.Contract(config.rootContractAddress, ['function registry() view returns (address)'], provider);
        const address = yield contract.registry();
        return address;
    });
}
function getTldData(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { config, tldLabel, provider } = params;
        if (!config)
            throw Error('Not connected to SmartContract');
        if (!provider)
            throw Error('No provider');
        const contract = new ethers_1.Contract(config.rootContractAddress, [
            'function getTld(bytes32) view returns ((address, address, string, string, string, bool, bytes32, bytes32))',
        ], provider);
        const tldDataRaw = yield contract.getTld(tldLabel);
        const [controller, registrar, tld, name, symbol, locked, node, label] = tldDataRaw;
        return {
            controller: controller,
            registrar: registrar,
            tld: tld,
            name: name,
            symbol: symbol,
            locked: locked === 'true',
            node: node,
            label: label,
        };
    });
}
function getTlds(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const { provider, config } = params;
        if (!provider)
            throw Error('No provider');
        if (!config)
            throw Error('Not connected to SmartContract');
        const contract = new ethers_1.Contract(config.rootContractAddress, [
            'function listTlds() view returns ((address, address, string, string, string, bool, bytes32, bytes32)[])',
        ], provider);
        const tldsRaw = (yield contract.listTlds());
        const tlds = tldsRaw.map((tldRaw) => {
            const [controller, registrar, tld, name, symbol, locked, node, label] = tldRaw;
            return {
                controller: controller,
                registrar: registrar,
                tld: tld,
                name: name,
                symbol: symbol,
                locked: locked === 'true',
                node: node,
                label: label,
            };
        });
        return tlds;
    });
}
exports.rootFetchers = {
    getRegistryAddress,
    getTlds,
    getTldData,
};
//# sourceMappingURL=root.fetchers.js.map